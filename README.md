# Genetic Programming 

## Intro
The goal of this project was to create a website that enables the user to generate a mathematical function best approximating values for given points. The website is hosted at https://vulwsztyn.github.io/genetic-programming/.

## UI
The user is presented with a number of input fields to tweak the parameters of the genetic programming algorithm.

- `Problem type` - defines whether trhe problem should generate a funciton meant for real numbers, integers, or booleans. Influances the set of possible funcions.
- `Population size` - defines how many specimen should a generation contain
- `Max tree depth` - defines maximal depth of the equation tree generated by the algorithm
- `Tournament Size` - defines how many specimen enter the tournament. Only the best exists.
- `Crossover Probability` - probability of choosing crossover operation instead of mutation to ccreates next specimen(s).
- `Points` -  points to be approximated
- `Possible leaves` - defines the possible values in leaves of the equation tree, a line should contain either a value (e.g. `3.14`) or a range (e.g. `(-10,10)`), disabled for booleans. Automatically contains all variables (i.e. `x0, x1, x2, ...`).
- `Possible functions` - defines a set of funcions that can be used to create the equation tree

The user is also presented with 4 buttons:
- `Create first generation` - create a generation of `Population size` random sprcimen, disables most of input fields
- `Create next generation` - create a generation of `Population size` sprcimen, if a generation is already created then as their offspring otherwise random
- `Create n generations` - equivalent to clicking `Create next generation` `n` times - `n` is a value from the following input field
- `Reset` - enables inputs and resets the population

## Logic
### Example specimen:
![Equation Tree](/assets/eq_as_tree.png)

Algorithm generates a population of specimen that can be typed so:
```javascript
interface TNode { //Leaf node
    type: 'T'
    value: Number | boolean // value if the  node is leaf node
    level: Number // integer
}
interface FNode { // function node
    type: 'F'
    name: string // name of function 
    level: Number // integer
    children?: Node[], // parameters of a function, length is equal to the arity of the function
}
type Node = TNode | FNode
```

If the generation is the first one the specimen are generated randomly (uniformely) from all possible values of the node, that is all user selected functions and leaf values. A generation is always sorted by fitness.

If the generation is not the first one it is generated by mutation and crossing over of the specimen from previous generation. Whether next specimen(s) will be created by mutation or crossover is random (with probability of crossover equal to `Crossover Probability` parameter). Mutation generates one child from one "parent", crossover generates two children from two "parents".

All parents are chosen by tournament i.e. since the generation is sorted by fintess a `Tournament Size` of indexes is randomly generated and the lowest is chosen.

Mutation is the replacement of a random node in the specimen with a new randomly generated node.

Crossover is the exchange of randomly chosen nodes (subtrees) from both parents.